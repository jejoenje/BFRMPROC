### BFRM correct SINGLE FILE v2.R
### This file clears out any recognised errors from a .csv file generated by a BFRM feeder reader meter.
###
### It has three key parts:
### - Choose & import a file, 

### 1. Import and 'clean' a single error type (two reads on same line) from data
### 2. Split data strings into date/time and logged data segments
### 3. Process data/time string into readable date and time and log string into 'antenna' and 'code' part.
### The processed data is then exported as a new data file in the same folder as the original file, with the suffix _proc


### 1. Import and clean data

# Choose file path
file_path <- file.choose()
# Scan data from file into data frame
dat <- read.table(file_path,sep='\n', header=T)

print("Cleaning logger data ..")

# Remove lines saying "logger" from the first column
dat <- as.data.frame(dat[!(grepl("logger",dat[,1])),])
# Add index column:
dat <- cbind(1:nrow(dat),dat)
# Name columns 'idx' and 'log', latter should be time/date string and the logged data separated by a comma (10 chars before, and 12 chars after the comma, 
#  23 chars in total).
names(dat) <- c('idx','log')
# Express 'log' as vector (not factor)
dat$log <- as.vector(dat$log)

# Identify cases of 'log' that are equal to and unequal to 23 chars (no errors, errors, respectively)
dat_noerr <- dat[nchar(dat$log)==23,]
dat_err <- dat[nchar(dat$log)!=23,]

# For the cases that have errors, split the log string in half
#  (note that this assumes that the error is two subsequent reads appearing on the same line)
dat_err1 <- substring(dat_err$log, 1,nchar(dat_err$log)/2)
dat_err2 <- substring(dat_err$log, (nchar(dat_err$log)/2)+1, nchar(dat_err$log))
# Transform the resulting vectors into dataframes with relevant row numbers:
dat_err1 <- data.frame(idx=dat_err$idx, log=dat_err1)
dat_err2 <- data.frame(idx=dat_err$idx, log=dat_err2)
# Add a fraction to each row number for the "second" of the two error strings, to allow for easy inserting in the original data:
dat_err2$idx <- dat_err2$idx+0.1
# Combine the two resulting dataframes and order by index:
dat_correct <- rbind(dat_err1, dat_err2)
dat_correct <- dat_correct[order(dat_correct$idx),]

# Now combine the original reads with no errors with the ones corrected above and again order by index to retain the original read order:
dat_out <- rbind(dat_noerr, dat_correct)
dat_out <- dat_out[order(dat_out$idx),]
# Clean up idx as it's no longer needed:
dat_out$idx <- NULL


### 2. Separate timedate and logger data
print("Splitting logger data ..")
dat_out <- apply(dat_out, 1, function(x) strsplit(x, ','))
out1 <- as.vector(unlist(lapply(dat_out, function(x) unlist(x)[1])))
out2 <- as.vector(unlist(lapply(dat_out, function(x) unlist(x)[2])))
# Combine these into a dataframe with two columns and force to vector format:
out <- data.frame(out1=out1, out2=out2)
out$out1 <- as.vector(out$out1)
out$out2 <- as.vector(out$out2)

dat <- out
names(dat) <- c('DT','LOG')

### 3. Process time/date and logger data

print("Checking data ..")
# Remove all occurrences of 'logger' text:
dat <- dat[grep("logger",dat$DT,invert=T),]
print("Checking if DT or LOG lines have correct character counts...")
# Which DT lines are different to 10 chars?
test1 <- which(apply(as.matrix(dat$DT),1,nchar)!=10)
# Which LOG lines are different to 12 chars?
test2 <- which(apply(as.matrix(dat$LOG),1,nchar)!=12)
# Stop if either test 1 or test 2 returns incorrect character counts:
if ( length(test1)>0 | length(test2)>0 ) {
  stop(paste('Lines', paste(test1,collapse=','), 'have incorrect character counts',collapse='T'))
}

print("Processing date/time. WARNING: YEAR SET TO CURRENT SYSTEM YEAR - IF POSSIBLY INCORRECT, PLEASE SET MANUALLY")
# Lift datetime value out of DT string for procfilename <- paste("corrected", strsplit(args[1],'/')[[1]][length(strsplit(args[1],'/')[[1]])],sep='_')

essing
dt <- strptime(dat$DT, format="%m%d%H%M%S")
# Extracte month, day and time from the strptime value and store as separate columns:
dat$year <- format(dt, "%Y")
dat$month <- format(dt, "%m")
dat$day <- format(dt, "%d")
dat$time <- format(dt, "%H:%M:%S")
rm(dt)
# Re-build datetime (strptime) object with correct year and store as column for processing purposes:
dat$dt <- strptime(paste(dat$day, dat$month, dat$year, dat$time), "%d %m %Y %H:%M:%S")
dat$year <- NULL
dat$month <- NULL
dat$day <- NULL
dat$time <- NULL
dat$DT <- NULL

print("Processing LOG value...")
dat$LOG <- as.vector(dat$LOG)
# Extract antenna value from LOG and store as column:
dat$ant <- substring(dat$LOG, 1, 2)
# Extract PIT id from LOG value and store as column:
dat$pit <- substring(dat$LOG, 3, nchar(dat$LOG))

print("Checking if all date/time values are in sequence...")
for(i in 2:nrow(dat)) {
  if(!as.numeric(dat$dt[i]-dat$dt[i-1])>=0) stop('Time values NOT in order - stopped processing!')
}

dat <- data.frame(dt=dat$dt, ant=dat$ant, pit=dat$pit)

### Write output data file:
splits <- gregexpr("/", file_path)[[1]]
path <- substring(file_path, 1, splits[length(splits)])
file <- substring(file_path, splits[length(splits)]+1)
newfile <- gsub("[].[]","_proc.", file)
outputpath <- paste(path, newfile, sep='')
write.csv(dat, outputpath, row.names=F)


